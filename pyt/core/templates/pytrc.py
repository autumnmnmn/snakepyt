
if session.snakepyt_version != (0, 2):
    session.log("this pytrc.py was based on a template generated by an outdated unstable version of snakepyt. it may need to be updated", mode="warning")

session.env.OUT = None # path; where should snakepyt put sketch outputs
session.env.IN = None # path: where should sketches look for input data
session.env.SKETCH = None # path: where should snakepyt look for your sketches

session.env.TEMPLATE = "verbose" # "basic" for a more barebones sketch template

# preferred interpreter to use when launching a python session inside the snakepyt repl
session.env.PYTHON_PATH = None # path: to your preferred python interpreter

# shortcuts for opening a bash session inside the snakepyt repl
# session.favorite_dirs = { "dir1": "/your/path/here", "dir2": "/other/path" }

from argparse import ArgumentParser

parser = ArgumentParser("hello_world")
parser.add_argument("name", type=str, default="world")

@command("hello_world", "hello", arg_parser=parser)
def cmd_hello_world(session, args):
    '''
        The `@command(...)` decorator takes any number of `str` arguments. The first is the
        canonical name of the command, the rest are aliases that can be used to run the
        same command.

        A command function accepts a `session: pyt.core.session.PytSession` and a
        set of args. If an `argparse.ArgumentParser` is passed to the @command decorator,
        the args will be an argparse.Namespace. Otherwise, args is a `str`.

        Commands and aliases defined in this file can override names of builtin commands.
    '''
    session.log(f"hello, {args.name}!")

